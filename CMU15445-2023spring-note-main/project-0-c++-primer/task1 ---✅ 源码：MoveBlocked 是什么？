✅ 源码：MoveBlocked 是什么？

/// 一个特殊类型，用于测试中禁止移动构造和移动赋值操作
class MoveBlocked {
 public:
  explicit MoveBlocked(std::future<int> wait) : wait_(std::move(wait)) {}

  MoveBlocked(const MoveBlocked &) = delete;
  MoveBlocked(MoveBlocked &&that) noexcept {
    if (!that.waited_) {
      that.wait_.get();
    }
    that.waited_ = waited_ = true;
  }

  auto operator=(const MoveBlocked &) -> MoveBlocked & = delete;
  auto operator=(MoveBlocked &&that) noexcept -> MoveBlocked & {
    if (!that.waited_) {
      that.wait_.get();
    }
    that.waited_ = waited_ = true;
    return *this;
  }

  bool waited_{false};
  std::future<int> wait_;
};
--------------------------------------------------------------------------------------------------
✅ 那么，MoveBlocked(std::future<int> wait) 是什么意思？

std::future<int> f = ...;
MoveBlocked m(std::move(f));  // ✅ 你把这个 future 交给 m 管理
也就是说：

MoveBlocked 的构造函数接收这个 “future” 对象

它负责将来某个时间 .get() 拿到结果



--------------------------------------------------------------------------------------------------
✅ std::promise / std::future 的本质：线程间的“一次性通知通道”
✅ 是谁写？谁读？
对象	作用	谁使用
promise	写端/设置结果	子线程
future	读端/获取结果	主线程

这就是一个 单向通道，可以：

设置值 ✅

读取值 ✅

设置异常 ❗

它底层基于：

互斥锁（mutex）

条件变量（cond_var）

信号通知（notify_one()）

✅ 所以你说得对：
promise.set_value() 就像是一个信号通知
future.get() 就像是一个阻塞等待直到有通知为止

✅ 类比系统调用 epoll / poll 的角度：
方面	std::promise/future	epoll / poll
设计层次	C++ 标准库	操作系统内核层
通信模型	一次性同步通信	多次性事件驱动监听
通知机制	set_value → 唤醒 get()	内核事件触发 → 唤醒监听者
阻塞方	future.get() 阻塞	epoll_wait() 阻塞
唤醒机制	promise 内部条件变量通知	内核中断触发 FD 活跃通知
使用场景	线程之间传值（一次）	大量 IO 事件并发高效监听


[promise/future]                    [epoll/poll]
 ┌────────┐                          ┌────────────┐
 │ thread │                          │  process   │
 │   T1   │ set_value(42) → 🔔 →     │ epoll_wait │
 └────────┘                          └────────────┘
     ↓                                    ↓
 ┌────────┐                         ┌────────────┐
 │future  │ ← get() ← blocks        │ 事件触发   │
 │   T0   │                         │  fd 活跃   │
 └────────┘                         └────────────┘

✅ 本质区别
项目	std::promise/future	epoll / poll
通信方向	单次发送 + 阻塞等待	多事件监听 + 非阻塞唤醒
是否可复用	❌ 一次性用完	✅ 支持反复监听
可传递值	✅ 可以传结果（int、对象等）	❌ 只知道哪个 fd 活跃，不传数据
底层依赖	C++ 条件变量 + mutex	Linux 内核 select/poll/epoll
--------------------------------
std::promise / future：

更像 “一次性的消息队列+阻塞接收”

用于线程间通信或任务结果获取

支持传值、异常

epoll / poll：

更像 “多路事件注册+内核通知”

用于 I/O 多路复用，高并发网络服务器（如 Nginx）

----------------------------------


----------------------------------------------------------------------------------------------------
#include <future>	引入异步通信工具：std::promise 和 std::future


#include <iostream>
#include <thread>
#include <future>  // 💡 future 就在这

int Work() {
  std::this_thread::sleep_for(std::chrono::seconds(2));  // 假装干2秒的活
  return 42;  // 干完返回一个结果
}

int main() {

//promise 是写端，future 是读端。通过这个 pair 实现线程间通信
  std::promise<int> p;                      // 🎁 我创建一个“承诺”：我以后会给你一个 int
  std::future<int> f = p.get_future();      // 📬 拿到对应的“收件箱 future”

//[&p]：通过引用捕获 promise 对象
  std::thread t([&p]() {                    // 💡 开个线程，干点事
    std::this_thread::sleep_for(std::chrono::seconds(2));
    p.set_value(42);                        // 💥 两秒后，结果来了！承诺兑现
  });

  std::cout << "等结果...\n";
  int result = f.get();                     // ⏳ 卡住这里，一定等到结果为止
  std::cout << "结果是：" << result << "\n";

  t.join();
}







