join()	等线程执行完，主线程才继续	同步（阻塞等待）	主线程依赖子线程结果
detach()	分离线程，独立运行	异步（主线程不管）	后台任务、不关心结果


✅ 1. thread.join() —— 等你跑完我再走

std::thread t(func);
t.join();  // 主线程会卡住，等 t 线程跑完
🔍 效果：
主线程 等待 t 线程运行完毕后再继续执行。

类似 C 语言里的 pthread_join()。
---------------------------------------------------------
如果你需要获取线程结果、或者线程访问共享资源，必须使用 join()。
---------------------------------------------------------
⚠️ 注意：
如果你不调用 join() 或 detach()，程序会崩溃（std::terminate）！

-------------------------------------------------------
thread.detach() —— 放你自由，跑完自己收尸

std::thread t(func);
t.detach();  // 主线程不会等你，t 自己跑自己的
------------------------------------------------------
主线程 创建线程后就“撒手不管”，线程独立运行。

类似 C 语言里的 pthread_detach()。

用于后台处理、写日志、上传网络、异步任务等不需要等结果的情况。
--------------------------------------------------------

📌 标准文档的解释（C++11 开始）：
If join() or detach() is not called before a std::thread object is destroyed, the program calls std::terminate().

翻译：

如果 std::thread 被销毁前，没有 join() 或 detach()，程序会直接终止。

“线程要善终，join 或 detach！”
否则 C++ 会认为你失职，直接 std::terminate() 报错！


