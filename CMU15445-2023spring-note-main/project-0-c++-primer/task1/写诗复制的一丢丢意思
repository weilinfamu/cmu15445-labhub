❗不要和变量的 const 混淆！
这儿的意思是：

“我保证这个函数不会修改当前的这个 Trie 对象的任何成员变量”

举个例子：

Trie a;
Trie b = a.Put<int>("abc", 42);  // ✅ a 不变，b 是新 Trie
所以：

this->root_ 不会被修改（immutable）

Put() 会创建一个 新 Trie 对象，并返回它！

✅ -> Trie
这个函数返回的是一个新的 Trie 对象。

这也就是写时复制的体现：

原来的 Trie 不动，返回一个新版本（共享一部分结构）
------------------------------------------------------------------------------------------------------
template <class T>
auto Put(std::string_view key, T value) const -> Trie;
用人话讲：

“这是 Trie 类的一个模板函数，它接受一个 key 和一个值，把它们插入到一个新 Trie 里，返回这个新 Trie。我不会修改当前对象。”

------------------------------------------------------------------------------------------------------

🌟 更准确一点讲：

auto Put(...) const -> Trie;
这个 const 修饰的是 函数本身，意思是：

“这个函数承诺不会修改当前对象的任何成员变量”

也就是说：

this->root_ 不会被改

原本的 Trie 是不会动的

你只能创建一个新的 Trie 并返回它


------------------------------------------------------------------------------------------------------



