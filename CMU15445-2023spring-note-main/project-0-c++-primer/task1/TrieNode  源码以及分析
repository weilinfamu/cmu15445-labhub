// A TrieNodeWithValue is a TrieNode that also has a value of type T associated with it.
template <class T>
class TrieNodeWithValue : public TrieNode {
 public:
  // Create a trie node with no children and a value.
  explicit TrieNodeWithValue(std::shared_ptr<T> value) : value_(std::move(value)) { this->is_value_node_ = true; }

  // Create a trie node with children and a value.
  TrieNodeWithValue(std::map<char, std::shared_ptr<const TrieNode>> children, std::shared_ptr<T> value)
      : TrieNode(std::move(children)), value_(std::move(value)) {
    this->is_value_node_ = true;
  }

  // Override the Clone method to also clone the value.
  //
  // Note: if you want to convert `unique_ptr` into `shared_ptr`, you can use `std::shared_ptr<T>(std::move(ptr))`.
  auto Clone() const -> std::unique_ptr<TrieNode> override {
    return std::make_unique<TrieNodeWithValue<T>>(children_, value_);
  }

  // The value associated with this trie node.
  std::shared_ptr<T> value_;
};
-------------------------------------------------------------------------------------------------------------------
核心设计意图
这个TrieNode类的设计目标是:

支持不可变(immutable)数据结构
实现写时复制(copy-on-write)优化
作为可能存储值的节点的基类
--------------------------------------------------------------

主要组件解析
1. 子节点存储

✅ 原始声明复习一下：

std::map<char, std::shared_ptr<const TrieNode>> children_;
🔍 拆成四个部分来讲解：
部分	含义
std::map<char, ...>	一个映射结构，key 是字符（char），表示一层 Trie 的分支
std::shared_ptr<...>	每个字符对应一个共享智能指针
const TrieNode	指向一个 不可修改的 TrieNode 对象
children_	成员变量名，代表“子节点集合”


------------------------------------------------------------------------------------------------------------------------------------------

什么是 std::shared_ptr<const TrieNode>？
我们来从内向外读：

“一个指向 const TrieNode 的智能指针，支持多个地方共享引用。”
------------------------------------------------------------------------------------------------------------------------------------------
注意：

它是一个类实例没错（就是 TrieNode 对象）
加了 const，意思是：通过这个 shared_ptr，你只能读，不能改

------------------------------------------------------------------------------------------------------------------------------------------
❗ 注意这个 const 不是 shared_ptr 本身是 const！
👇 下面对比一下你就懂了：

✅ 当前定义：

std::shared_ptr<const TrieNode> p;
✅ 可以修改 p（指针变量本身可赋新值）

❌ 不能通过 p 去改 *p 指向的 TrieNode

❌ 如果写成这样：

const std::shared_ptr<TrieNode> p;
❌ p 自己是常量，不能赋新指针

✅ 你可以改 *p 指向的 TrieNode（指针能改内容）
------------------------------------------------------------------------------------------------------------------------------------------




