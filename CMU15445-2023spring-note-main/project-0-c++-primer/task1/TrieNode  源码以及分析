// A TrieNodeWithValue is a TrieNode that also has a value of type T associated with it.
template <class T>
class TrieNodeWithValue : public TrieNode {
 public:
  // Create a trie node with no children and a value.
  explicit TrieNodeWithValue(std::shared_ptr<T> value) : value_(std::move(value)) { this->is_value_node_ = true; }

  // Create a trie node with children and a value.
  TrieNodeWithValue(std::map<char, std::shared_ptr<const TrieNode>> children, std::shared_ptr<T> value)
      : TrieNode(std::move(children)), value_(std::move(value)) {
    this->is_value_node_ = true;
  }

  // Override the Clone method to also clone the value.
  //
  // Note: if you want to convert `unique_ptr` into `shared_ptr`, you can use `std::shared_ptr<T>(std::move(ptr))`.
  auto Clone() const -> std::unique_ptr<TrieNode> override {
    return std::make_unique<TrieNodeWithValue<T>>(children_, value_);
  }

  // The value associated with this trie node.
  std::shared_ptr<T> value_;
};
-------------------------------------------------------------------------------------------------------------------
æ ¸å¿ƒè®¾è®¡æ„å›¾
è¿™ä¸ªTrieNodeç±»çš„è®¾è®¡ç›®æ ‡æ˜¯:

æ”¯æŒä¸å¯å˜(immutable)æ•°æ®ç»“æ„
å®ç°å†™æ—¶å¤åˆ¶(copy-on-write)ä¼˜åŒ–
ä½œä¸ºå¯èƒ½å­˜å‚¨å€¼çš„èŠ‚ç‚¹çš„åŸºç±»
--------------------------------------------------------------

ä¸»è¦ç»„ä»¶è§£æ
1. å­èŠ‚ç‚¹å­˜å‚¨

âœ… åŸå§‹å£°æ˜å¤ä¹ ä¸€ä¸‹ï¼š

std::map<char, std::shared_ptr<const TrieNode>> children_;
ğŸ” æ‹†æˆå››ä¸ªéƒ¨åˆ†æ¥è®²è§£ï¼š
éƒ¨åˆ†	å«ä¹‰
std::map<char, ...>	ä¸€ä¸ªæ˜ å°„ç»“æ„ï¼Œkey æ˜¯å­—ç¬¦ï¼ˆcharï¼‰ï¼Œè¡¨ç¤ºä¸€å±‚ Trie çš„åˆ†æ”¯
std::shared_ptr<...>	æ¯ä¸ªå­—ç¬¦å¯¹åº”ä¸€ä¸ªå…±äº«æ™ºèƒ½æŒ‡é’ˆ
const TrieNode	æŒ‡å‘ä¸€ä¸ª ä¸å¯ä¿®æ”¹çš„ TrieNode å¯¹è±¡
children_	æˆå‘˜å˜é‡åï¼Œä»£è¡¨â€œå­èŠ‚ç‚¹é›†åˆâ€


------------------------------------------------------------------------------------------------------------------------------------------








