我们以你问的 primer/trie.cpp 举例解释命名规范和原因：
为什么叫 primer/trie.cpp？
============================================================================================================================
含义如下：

primer/ 是“预热项目”目录，表示这个目录是 Project 0：入门项目 的内容。

trie.cpp 是实现文件，表示这里实现的是 Trie 树（一种前缀树结构）的逻辑。

所以 primer/trie.cpp 就表示：“入门项目中，实现 Trie 树的代码”。
============================================================================================================================
📁 项目目录一览 + 中文说明
目录 / 文件	用途 / 内容
lab-p0/	BusTub 主代码所在目录，是你写代码的地方
lab-p0/src/	源码实现目录（如 buffer、execution 等子系统）
lab-p0/src/include/	各个模块的头文件（类的定义）
lab-p0/test/	项目测试代码，使用 GoogleTest 编写
lab-p0/tools/	工具代码，例如 SQL Shell（可以输入 SQL 查询）
lab-p0/third_party/	外部依赖库（如 gtest、argparse）
build_support/	构建/安装脚本（如依赖安装）
CMU15445-2023spring-note-main/	作者写的课程笔记，讲解项目原理
note.md、project_tips.md	项目建议、经验总结
============================================================================================================================

🎯 为什么这样设计结构？有什么工程意义？
设计方式	工程上的意义 / 目的
每个功能模块单独放进子目录	模块化管理、解耦易维护
.h 和 .cpp 分离	头文件放接口，源文件放实现，清晰职责
test/ 分离测试代码	测试和业务逻辑分离，方便管理与验证
tools/ 放工具如 SQL Shell	工具独立，不影响主代码结构
third_party/ 放外部库	避免污染主项目目录，方便管理依赖版本
用 cmake 构建工程	可跨平台构建，易于配置编译参数
=============================================================================================================

✅ 1. third_party/：为啥要有“第三方库”？gtest 和 argparse 是啥？
在一个项目里，你不可能所有功能都自己造轮子，比如你不想自己造测试框架、也不想自己解析命令行参数。于是就用别人写好的库，这些就叫 第三方库（third-party libraries）。
=============================================================================================================
📦 gtest 是啥？
全称：Google Test

用途：给你的 C++ 项目写测试用例的库

举例子：

你写了一个函数：

cpp
Copy
Edit
int Add(int a, int b) {
  return a + b;
}
你可以用 gtest 写测试用例验证它是否正确：

TEST(MyTest, AddFunction) {
  EXPECT_EQ(Add(1, 2), 3);
}
BusTub 项目会自动运行这些 TEST(...) 来确保你实现的东西是对的。
===========================================================================================
📦 argparse 是啥？
全称：Argument Parser
用途：解析命令行参数
举例子：

你在命令行运行：
./main --mode=debug --port=1234
argparse 可以帮你提取出：
args["mode"] = "debug";
args["port"] = "1234";
让你专注业务逻辑，不用写低级解析代码。

===========================================================================================
✅ 2. tools/ 目录里的“工具”是干啥的？比如说 SQL Shell 是啥？
📂 tools/ 是用来放项目里“开发辅助工具”的目录。
它不负责数据库本身，而是提供给“人类”用来和数据库交互的工具。

🧠 举例：SQL Shell 是啥？
SQL Shell 就像一个“命令行界面”，你可以手动输入 SQL 语句，然后数据库给你结果。

比如你启动 Shell：
./shell
然后你输入：
SELECT * FROM students WHERE age > 20;
它就会调用你写的数据库代码，把结果返回给你。

就像你在真实数据库（MySQL、Postgres）里操作一样。
===========================================================================================
✅ 3. CMake 是干啥的？为啥说它“易配置编译参数”？
🔧 CMake 是一个跨平台构建工具
你不需要手动写复杂的 g++ -Iinclude ... -c foo.cpp -o foo.o，而是写个 CMakeLists.txt，然后自动生成 Makefile。

🍱 怎么配置编译参数？
你运行 CMake 时传参来控制行为，比如：
cmake -DCMAKE_BUILD_TYPE=Debug -DBUSTUB_SANITIZER=thread ..

解释如下：

-DCMAKE_BUILD_TYPE=Debug
➤ 打开调试信息，比如你要用 gdb 调试。

-DBUSTUB_SANITIZER=thread
➤ 启用线程安全检查，自动报出线程访问冲突。

还有别的参数，比如你可以打开 -DWITH_LOG=ON 就能看到日志。

这种“配置编译行为”的方式，就叫“易配置编译参数”。
======================================================================================================================================================================================
✅ 4. 运行测试 make primer_test 是啥意思？
你写完代码后，可以通过这个命令运行 Project 0 的单元测试 来自动验证是否正确。

流程是：
# 1. 构建项目
mkdir build && cd build
cmake ..
make -j

# 2. 运行 primer_test
make primer_test

=====================================================================================================

它会输出每个测试是否通过：

[==========] Running 5 tests from TrieTest.
[ RUN      ] TrieTest.SimpleInsert
[       OK ] TrieTest.SimpleInsert (0 ms)
[ RUN      ] TrieTest.InsertAndGet
[       OK ] TrieTest.InsertAndGet (1 ms)
...
这些测试就是验证你写的 trie.cpp 是否正确。

你每写一段代码，就应该配对一个测试，确保没写错。










